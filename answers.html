Q1. Where are we instantiating instances of the Property class?
In the console file, passing values to the initialize function.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
The .save function passed throught the pg gem interface.

Q3. In console.rb, which lines modify the database?
The lines containing .save .update & .delete functions.

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
The id is assigned by the database, not the ruby class.

Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?
It is assigned back to ruby using the @id = db.exec_prepared("save", values)[0]['id'].to_i code.

Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?
So that it only assigns and id to a valid record.

Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?
Simply because some methods are applied to specific objects/records where as others are applied to the entire database/table.

Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?
This is passed as an array of hashes.

Q9. Why do we use prepared statements when performing database operations?
To protect against SQL injection attacks.
